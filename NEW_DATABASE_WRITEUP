The library management system is built around a relational SQLite database that is dynamically controlled through a structured Python program. The program acts as both a data-entry controller and a validation layer, while the database serves as the central storage system. Together, they create a complete information architecture where multiple entities—authors, books, borrowers, loans, and book copies—are interconnected through foreign keys and enforced through program-level logic.

1. Database Structure: Entities and Relationships

Your actual library_database.db contains five functional tables: Authors, Library_database (books), Borrowers, Loans, and Book_Locations, along with SQLite’s internal sqlite_sequence table. These tables work together to represent the core parts of a real library system. Each table stores a specific type of information, but the relationships between them allow the program to track how items relate to each other—an essential feature of any functional database system.

Authors Table

This table stores all authors in the system. Each author has a unique Author_ID, which becomes a reference point for books. Instead of storing the author name repeatedly in every book record, the system uses a single integer key, ensuring efficient storage and consistency. This creates a one-to-many relationship: one author can be linked to many books.

Library_database Table (Books)

The books table is the core of the database and depends heavily on relational connections. It stores each book’s details—title, genre, page count, and publication date. Each book also contains an Author_ID foreign key, linking it back to the Authors table.

Interestingly, your actual .db stores publication dates as REAL, not TEXT. This means the table previously existed and retained an older column type. The program still treats dates as strings through validation, and because SQLite is flexible, this mismatch does not break functionality. This demonstrates how SQLite’s dynamic typing adapts to changing program versions.

This table branches into several other tables, making it central to system operations:

Loans reference Book_ID

Book_Locations reference Book_ID

Borrowers Table

Borrowers are stored in a separate table with unique Borrower_IDs. This table represents the people interacting with the library. Each loan record connects a borrower to a specific book using this ID.

This creates another one-to-many relationship:
One borrower → can appear in multiple loan records.

Loans Table

The Loans table is the system’s transactional layer, linking books to borrowers over time. Every loan contains:

Book_ID (what was borrowed)

Borrower_ID (who borrowed it)

Loan date

Optional return date

This forms a many-to-many relationship between books and borrowers, but implemented through a bridging table. Instead of duplicating data, Loans stores only the IDs, connecting the two parent tables.

An important detail: the Python program does not enable SQLite’s PRAGMA foreign_keys = ON, meaning SQLite itself does not enforce the relationships. Instead, the Python GUI enforces data integrity by only allowing users to select valid books and borrowers via choiceboxes. This is effective because the user interface eliminates the possibility of invalid IDs entering the database.

Book_Locations Table

This table tracks where each physical copy of a book is placed and how many copies exist. It links directly back to the Books table through Book_ID.

This creates another one-to-many relationship:
One book → may exist in multiple Locations.

Through this design, the system supports scenarios where a book is stored on multiple shelves, in multiple rooms, or even in multiple branches.

2. How the Python Program Controls and Integrates the Database

The Python program acts as both the front-end and the logic controller of the entire system. When the program starts, it connects to the database and checks whether all required tables exist. If tables are missing, they are automatically created. Because your .db already contains the tables, the program simply connects and proceeds.

Graphical User Interface & Validation

User interaction occurs through EasyGUI, ensuring clean and error-free data input. The program validates:

Date formats (YYYY-MM-DD)

Positive integers

Non-empty fields

This prevents corrupted or inconsistent data from reaching the database. For example, a book cannot be added unless the publication date is valid and an author already exists.

3. Data Flow & Interconnections During Operations

Each operation in the system demonstrates the use of SQL relationships:

Adding a Book

The program retrieves all authors from the Authors table.

The user selects an author (ensuring a valid foreign key).

The book is inserted into Library_database with the selected Author_ID.

This links the book to its author through an enforced selection process.

Adding a Loan

The program retrieves all books and borrowers.

Users choose from existing items, ensuring foreign key correctness.

The system inserts a row into Loans containing:

Book_ID

Borrower_ID

Loan and return dates

This forms a record that ties the tables together without manually entering IDs.

Viewing Data

When viewing books or loans, the program performs SQL JOINs, combining related data from multiple tables to produce meaningful reports.

Example from your code:

SELECT L.Book_ID, L.Title, A.Author_Name
FROM Library_database L
LEFT JOIN Authors A ON L.Author_ID = A.Author_ID


This merge allows users to see book and author information together, even though they are stored separately.

Similarly, loans display borrower names and book titles through multi-table joins.

4. Integrity, Structure, and System Design

Although SQLite foreign key enforcement is not active by default, the program compensates through strong GUI-level validation. The user can only select existing authors, books, or borrowers, ensuring that all relationships remain valid.

The combination of:
- relational structure
- program-enforced selection
- structured validation
- SQL joins
- autoincrement primary keys

creates a stable and logically consistent database system.

Conclusion (Excellence-Level Insight)

The SQL library database in this system is not just a collection of tables; it is a purposefully engineered relational structure where each entity supports and enhances the functionality of others. The Python program acts as the intelligent controller, ensuring that the relationships—authors to books, borrowers to loans, books to locations—remain valid and meaningful.

The result is a robust, interconnected system where data flows smoothly between modules and where user actions are translated into structured SQL operations. The design effectively mirrors how real-world library databases are built: through linked entities, enforced relationships, and clear separation of data responsibilities.




